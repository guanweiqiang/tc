## 认证与单点登录设计说明

### 1. 认证模型概述

系统采用 **JWT + Redis** 的认证模型，实现无状态身份识别与强一致性的单点登录控制。

整体设计遵循以下原则：

- **JWT 仅用于身份识别**（证明“你是谁”）
- **Redis 作为登录态的唯一权威来源**（判断“你是否仍然处于登录状态”）
- 服务端不依赖 Session，不保存用户会话状态

---

### 2. JWT 设计

登录成功后，服务端签发 JWT 作为客户端的访问凭证。  
JWT 中包含以下核心信息：

- `userId`：用户唯一标识
- `jti`：JWT 的唯一标识（UUID），用于区分不同登录会话
- `iat` / `exp`：签发时间与过期时间

每次登录都会生成新的 `jti`，用于实现单点登录控制。

---

### 3. Redis 登录态设计

Redis 用于维护系统中**唯一有效的登录态**，结构如下：

- **Key**：`login:active:{userId}`
- **Value**：`jti`
- **TTL**：与 JWT 的剩余有效期保持一致

系统中任意时刻，一个 `userId` 在 Redis 中只会对应一个 `jti`。
新登录会覆盖旧的登录记录，从而使旧 token 自动失效。

Redis 被视为登录态的唯一权威来源：
- 若 Redis 中不存在登录记录，则视为登录已失效
- 即使 JWT 尚未过期，也不允许访问受保护资源

---

### 4. 单点登录（SSO）策略

系统采用 **“挤掉旧登录”** 的单点登录策略：

- 同一账号同一时间仅允许一个有效登录态
- 新登录会覆盖 Redis 中的旧登录记录
- 被覆盖的旧 token 在下一次请求时会被判定为无效

该策略可有效防止同一账号在多个设备同时使用。

---

### 5. 请求鉴权流程

每次受保护资源请求的鉴权流程如下：

1. 客户端在请求头中携带 `Authorization: Bearer <token>`
2. 拦截器校验 token 的合法性并解析 `userId` 与 `jti`
3. 从 Redis 查询 `login:active:{userId}`
4. 若 Redis 中不存在记录，判定为登录已过期
5. 若 token 中的 `jti` 与 Redis 中的 `jti` 不一致，判定为账号在其他设备登录
6. 校验通过后，将 `userId` 写入 ThreadLocal，供业务层使用

---

### 6. logout 设计

在当前认证模型下，logout 的语义为 **显式注销当前登录态**。

实现方式：
- 删除 Redis 中的 `login:active:{userId}` 记录
- 当前 token 立即失效，后续请求将无法通过鉴权

由于 JWT 为无状态机制，logout 并非销毁 token 本身，
而是通过移除服务端登录态实现失效控制。

---

### 7. 设计取舍说明

- 未使用传统 Session，而采用 JWT + Redis，以避免服务端会话状态
- Redis 被设计为登录态中心，确保登录状态语义清晰、可控
- 当 Redis 中不存在登录记录时，系统拒绝请求而非降级放行，以保证认证一致性与安全性
